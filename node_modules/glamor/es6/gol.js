var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

export function make() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return _extends({
    grid: [],
    added: [],
    removed: [],
    unchanged: [],
    width: options.width || 20,
    height: options.height || 20
  }, options);
}

export function set(board, x, y, live) {
  var newBoard = make(board);
  newBoard.grid[y] = [].concat(_toConsumableArray(board.grid[y] || []));
  if (live) {
    if (!board.grid[y] || !board.grid[y][x]) {
      newBoard.added.push({
        x: x,
        y: y
      });
    }
  } else {
    if (board.grid[y][x]) {
      newBoard.removed.push({
        x: x,
        y: y
      });
    }
  }
  newBoard.grid[y][x] = live;
  return newBoard;
}

export function get(board, x, y) {
  if (board.grid[y]) {
    return board.grid[y][x] || false;
  }
  return false;
}

export function step(board) {
  var newBoard = make(board);
  var _grid = [];

  var added = [];
  var removed = [];
  var unchanged = [];

  for (var i = board.width; i--;) {
    for (var j = board.height; j--;) {
      var state = next(board, i, j);
      if (state) {
        _grid[j] = [].concat(_toConsumableArray(_grid[j] || []));
        _grid[j][i] = state;

        if (!board.grid[j] || board.grid[j] && !board.grid[j][i]) {
          added.push({
            x: i,
            y: j
          });
        } else {
          unchanged.push({
            x: i,
            y: j
          });
        }
      } else {
        if (board.grid[j] && board.grid[j][i]) {
          removed.push({
            x: i,
            y: j
          });
        }
      }
    }
  }
  newBoard.grid = _grid;
  newBoard.added = added;
  newBoard.removed = removed;
  newBoard.unchanged = unchanged;
  return newBoard;
}

export function next(board, x, y) {
  // applies rules and sends back true or false on basis of live or dead
  if (get(board, x, y) === true) {
    // live cell
    switch (neighbors(board, x, y)) {
      case 0:
      case 1:
        return false;
      case 2:
      case 3:
        return true;
      default:
        return false;
    }
  } else {
    if (neighbors(board, x, y) === 3) {
      return true;
    }
  }
  return false;
}

function neighbors(board, x, y) {
  var ctr = 0;
  for (var i = x - 1; i < x + 2; i++) {
    for (var j = y - 1; j < y + 2; j++) {
      if (i >= 0 && i < board.width && j >= 0 && j < board.height && !(x === i && y === j) && get(board, i, j) === true) {
        ctr++;
      }
    }
  }
  return ctr;
}

export function str(board) {
  var str = [];
  for (var j = 0; j < board.height; j++) {
    for (var i = 0; i < board.width; i++) {
      str += get(board, i, j) ? 'O' : '.';
    }
    str += '\n';
  }
  return str;
}